<template>
    <div class="splitter-pannel">
        <svg viewBox="-125 -125 250 250" xmlns="http://www.w3.org/2000/svg">
            <circle cx=0 cy=0 r=50 stroke="currentcolor" fill="#0006" stroke-width=".5" opacity="0.6" />
            <template v-for="(a, i) in adjacency" :key="i" >
                <g v-if="a" :opacity="params.priority[i] ? 1 : 0.5">
                    <path d="M-5 -55l5 10 5 -10z" :fill="color(i)"
                        :transform="`rotate(${yaw[i]})` + (isInput(i) ? '' : 'rotate(180 0 -50)')"/>
                    <g :transform="circleTrans[i]">
                        <template v-if="!isInput(i) && params.priority[i]">
                            <circle cx=0 cy=0 r=16 fill="none" :stroke="color(i)" stroke-width="3"/>
                            <image v-if="props.building.filterId > 0"
                                :href="filterIcon" width=24 height=24 x=-12 y=-12></image>
                            <text v-else fill="currentcolor" x=0 y=0 textLength="24"
                                font-size="8" text-anchor="middle" dominant-baseline="middle">
                                过滤器
                            </text>
                        </template>
                        <circle v-else cx=0 cy=0 r=12 :fill="color(i)"/>
                    </g>
                </g>
            </template>
        </svg>
        <div class="model" ref="glRoot"></div>
    </div>
</template>

<script lang="ts" setup>
import { computed, inject, ref, watch, watchEffect } from 'vue';
import { BlueprintBuilding, SplitterParameters } from "@/blueprint/parser";
import { itemsMap } from '@/data';
import { AmbientLight, BoxGeometry, DirectionalLight, Matrix4, Mesh, MeshStandardMaterial, PerspectiveCamera, Scene, Vector2, Vector3, WebGLRenderer } from 'three';
import { attachRenderer } from '@/utils';
import { itemRecipeIconUrl } from '@/data/icons';
import { buildingInfoKey, rendererKey } from '@/define';

const props = defineProps<{
    building: BlueprintBuilding,
}>();

const mainRenderer = inject(rendererKey)!.value;
const buildingInfo = inject(buildingInfoKey)!.value!;

const adjacency = computed(() => {
    return buildingInfo.adjacency[props.building.index];
})
const isInput = (i: number) => {
    return adjacency.value[i].outputObjIdx === props.building.index;
}
const color = (i: number) => {
    return isInput(i) ? '#AFFFFF' : '#FCE88F';
}

const posFromCamera = computed(() => {
    const pos = new Matrix4();
    mainRenderer.cameraPosVersion;
    const model = mainRenderer.getModel(props.building.index);
    if (model) {  // may be null when closing blueprint
        pos.multiplyMatrices(mainRenderer.camera.matrixWorldInverse, model);
    }
    return pos;
});

const offset = new Vector2();
const pos = new Vector3();
const defaultR = 90;
const offsetR = 16;
const circlePos = (i: number) => {
    const singleLine = props.building.modelIndex === 39
    let deg;
    let r = defaultR;
    if (singleLine) {
        deg = Math.floor(i / 2) * 180.0;
    } else {
        deg = 90 * i;
        r -= offsetR
    }
    const rad = (deg + props.building.yaw[0]) / 180.0 * Math.PI;
    const c = new Vector2(Math.sin(rad), -Math.cos(rad)).multiplyScalar(r);

    if (singleLine) {
        pos.setFromMatrixPosition(posFromCamera.value);
        const up = i % 2 === 1 ? 1 : -1;
        offset.set(pos.x, -pos.y).normalize().multiplyScalar(offsetR * up);
        c.add(offset);
    }
    return c;
}
const circlePoses = computed(() => {
    const ps = new Array<Vector2>(4);
    for (let i = 0; i < ps.length; i++) {
        ps[i] = circlePos(i);
    }
    return ps;
})
const circleTrans = computed(() => circlePoses.value.map(p => `translate(${p.x} ${p.y})`))
const yaw = computed(() => circlePoses.value.map(p => Math.atan2(p.y, p.x) / Math.PI * 180 + 90))

const filterIcon = ref('');
watchEffect(async () => {
    filterIcon.value = '';
    if (props.building.filterId <= 0)
        return;
    const name = itemsMap.get(props.building.filterId)!.icon;
    filterIcon.value = await itemRecipeIconUrl(name);
});

const camera = new PerspectiveCamera(50.0);
const renderer = new WebGLRenderer({ antialias: true });
renderer.setClearAlpha(0.0);
const glRoot = ref<HTMLElement | null>(null);
attachRenderer(glRoot, renderer)

const scene = new Scene();
const geometry = new BoxGeometry(1.0, 1.0, 1.0);
const material = new MeshStandardMaterial({
    color: 0xFFFFFF,
    opacity: 0.5,
    transparent: true,
    depthWrite: false,
});
const model = new Mesh(geometry, material);
model.matrixAutoUpdate = false;
const dirLight = new DirectionalLight();
dirLight.position.set(0, 0, 1);
dirLight.target = model;
const envLight = new AmbientLight(0xFFFFFF, 0.3);
scene.add(model, dirLight, envLight);

let animationFrame: null | number = null;
const updateModel = () => {
    animationFrame = null;
    pos.setFromMatrixPosition(posFromCamera.value);
    pos.normalize().multiplyScalar(8.0);
    model.matrix.copy(posFromCamera.value);
    model.matrix.setPosition(pos);
    camera.lookAt(pos);
    renderer.render(scene, camera);
}

watch(posFromCamera, () => {
    if (animationFrame === null) {
        animationFrame = requestAnimationFrame(updateModel);
    }
}, { immediate: true });

const params = computed(() => props.building.parameters as SplitterParameters);
</script>

<style lang="scss">
.splitter-pannel {
    position: relative;

    svg {
        inset: 0;
        display: block;
    }
    .model {
        position: absolute;
        inset: 30%;
    }
}
</style>
